name: Notify LINE from kintone

on:
  schedule:
    - cron: '0 16 * * *' # æ—¥æœ¬æ™‚é–“25æ™‚ï¼ˆç¿Œ1æ™‚ï¼‰
    - cron: '0 23 * * *' # æ—¥æœ¬æ™‚é–“8æ™‚
  workflow_dispatch:

jobs:
  notify:
    runs-on: ubuntu-latest

    steps:
    - name: Checkout code
      uses: actions/checkout@v3

    - name: Set up Node.js
      uses: actions/setup-node@v3
      with:
        node-version: 18

    - name: Install dependencies
      run: npm install axios dayjs

    - name: Run notification script
      env:
        KINTONE_TOKEN: ${{ secrets.KINTONE_TOKEN }}
        KINTONE_DOMAIN: ${{ secrets.KINTONE_DOMAIN }}
        LINE_TOKEN: ${{ secrets.LINE_TOKEN }}
        GROUP_ID: ${{ secrets.GROUP_ID }}
      run: |
        echo "Running notification..."
        node <<'EOF'
        const axios = require("axios");
        const dayjs = require("dayjs");
        const utc = require("dayjs/plugin/utc");
        const timezone = require("dayjs/plugin/timezone");

        dayjs.extend(utc);
        dayjs.extend(timezone);

        (async () => {
          const now = dayjs().tz("Asia/Tokyo");
          const hour = now.hour();
          const today = now.format("YYYY-MM-DD");
          const tomorrow = now.add(1, 'day').format("YYYY-MM-DD");

          const headers = {
            "X-Cybozu-API-Token": process.env.KINTONE_TOKEN
          };

          const appId = 10;
          const kintoneUrl = `https://${process.env.KINTONE_DOMAIN}/k/v1/records.json`;

          let messages = [];

          // â–¼ æœ¬æ—¥ã‚¢ãƒé€šçŸ¥ï¼ˆ8æ™‚é™å®šï¼‰
          if (hour === 8) {
            let msgToday = "ã€æœ¬æ—¥ã‚¢ãƒãƒ»å†ã‚¢ãƒé€šçŸ¥ã€‘\n\n";
            let hasApo = false;

            try {
              const resToday = await axios.get(kintoneUrl, {
                headers,
                params: {
                  app: appId,
                  query: `day >= "${today}T00:00:00" and day < "${tomorrow}T00:00:00" and eigyo_status in ("ä¿ç•™", "å†ã‚¢ãƒ")`
                }
              });

              const records = resToday.data.records;

              if (records.length > 0) {
                msgToday += "â–¼ æ–°è¦ã‚¢ãƒ\n";
                for (const r of records) {
                  msgToday += `é¡§å®¢åï¼š${r["line_name"].value}\nå•†è«‡æ™‚é–“ï¼š${dayjs(r["day"].value).tz("Asia/Tokyo").format("YYYY-MM-DD HH:mm")}\nå–¶æ¥­æ‹…å½“ï¼š${r["ooo"].value}\né›†å®¢çµŒè·¯ï¼š${r["apo"]?.value || "ä¸æ˜"}\n\n`;
                }
                hasApo = true;
              }

              const resToday2 = await axios.get(kintoneUrl, {
                headers,
                params: {
                  app: appId,
                  query: `day2 >= "${today}T00:00:00" and day2 < "${tomorrow}T00:00:00" and eigyo_status in ("ä¿ç•™", "å†ã‚¢ãƒ")`
                }
              });

              const records2 = resToday2.data.records;

              if (records2.length > 0) {
                msgToday += "â–¼ å†ã‚¢ãƒ\n";
                for (const r of records2) {
                  msgToday += `é¡§å®¢åï¼š${r["line_name"].value}\nå†ã‚¢ãƒæ™‚é–“ï¼š${dayjs(r["day2"].value).tz("Asia/Tokyo").format("YYYY-MM-DD HH:mm")}\nå–¶æ¥­æ‹…å½“ï¼š${r["ooo"].value}\né›†å®¢çµŒè·¯ï¼š${r["apo"]?.value || "ä¸æ˜"}\n\n`;
                }
                hasApo = true;
              }

              if (hasApo) {
                msgToday += "ã‚ˆã‚ã—ããŠé¡˜ã„ã„ãŸã—ã¾ã™ï¼";
                messages.push(msgToday);
              }
            } catch (e) {
              console.error("âŒ æœ¬æ—¥ã‚¢ãƒé€šçŸ¥ã‚¨ãƒ©ãƒ¼", e.response?.data || e.message);
            }
          }

          // â–¼ ã‚¢ãƒæœªå¯¾å¿œã‚¢ãƒ©ãƒ¼ãƒˆï¼ˆ25æ™‚é™å®šï¼‰
          if (hour === 1) {
            let msgOverdue = "ã€ã‚¢ãƒæœªå¯¾å¿œã‚¢ãƒ©ãƒ¼ãƒˆã€‘\nã‚¢ãƒæ—¥ã‚’éãã¦ã‚‚ã‚¹ãƒ†ãƒ¼ã‚¿ã‚¹ãŒã€Œä¿ç•™ã€ã®ãƒ¬ã‚³ãƒ¼ãƒ‰ãŒã‚ã‚Šã¾ã™âš ï¸\n\n";
            let hasOverdue = false;

            try {
              const resOverdue = await axios.get(kintoneUrl, {
                headers,
                params: {
                  app: appId,
                  query: `day < "${today}T00:00:00" and eigyo_status in ("ä¿ç•™")`
                }
              });

              const overdueRecords = resOverdue.data.records;

              if (overdueRecords.length > 0) {
                for (const r of overdueRecords) {
                  msgOverdue += `é¡§å®¢åï¼š${r["line_name"].value}\nã‚¢ãƒæ—¥ï¼š${dayjs(r["day"].value).tz("Asia/Tokyo").format("YYYY-MM-DD HH:mm")}\nå–¶æ¥­æ‹…å½“ï¼š${r["ooo"].value}\n\n`;
                }
                msgOverdue += "è‡³æ€¥ã”å¯¾å¿œã‚’ãŠé¡˜ã„ã„ãŸã—ã¾ã™ï¼";
                messages.push(msgOverdue);
              }
            } catch (e) {
              console.error("âŒ ã‚¢ãƒæœªå¯¾å¿œãƒã‚§ãƒƒã‚¯ã‚¨ãƒ©ãƒ¼", e.response?.data || e.message);
            }
          }

          // â–¼ LINEé€ä¿¡å‡¦ç†
          if (messages.length > 0) {
            for (const text of messages) {
              try {
                await axios.post("https://api.line.me/v2/bot/message/push",
                  {
                    to: process.env.GROUP_ID,
                    messages: [{ type: "text", text }]
                  },
                  {
                    headers: {
                      Authorization: `Bearer ${process.env.LINE_TOKEN}`,
                      "Content-Type": "application/json"
                    }
                  }
                );
              } catch (e) {
                console.error("âŒ LINEé€ä¿¡ã‚¨ãƒ©ãƒ¼", e.response?.data || e.message);
              }
            }

            console.log("ğŸ“¤ LINEé€šçŸ¥é€ä¿¡å®Œäº†");
          } else {
            console.log("âœ… é€šçŸ¥å¯¾è±¡ãªã—");
          }
        })().catch(e => {
          console.error("âŒ æƒ³å®šå¤–ã®ã‚¨ãƒ©ãƒ¼", e.response?.data || e.message);
        });
        EOF
